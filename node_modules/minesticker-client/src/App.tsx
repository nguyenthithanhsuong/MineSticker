import { useEffect, useState } from "react";
import {
  Character,
  Face,
  Matrix,
  Tile,
  TileTexture,
  SPRITE_SHEET,
  CHAR_SPRITE_SHEET,
  IDLE_SPRITE_SHEET,
  WALK_SPRITE_SHEET,
  PLACEFLAG_SPRITE_SHEET,
  TILE_COORDS,
  FACE_COORDS,
  NUMBER_COORDS,
  KEY_COORDS,
  CHAR_FULL_COORDS,
  CHAR_FEET_COORDS,
  IDLE_COORDS,
  WALK_COORDS,
  PLACEFLAG_COORDS
} from "../../shared";

interface GameState {
  rows: number;
  cols: number;
  character: Character;
  face: Face;
  tiles: string[][];
}

type GameStatus = "playing" | "won" | "lost";

function createMatrix(rows: number, cols: number, mines: number) {
  const matrix = new Matrix<Tile>(rows, cols, () => new Tile("tile0"));
  const total = rows * cols;
  const minePositions = new Set<number>();

  while (minePositions.size < mines && minePositions.size < total) {
    const random = Math.floor(Math.random() * total);
    minePositions.add(random);
  }

  minePositions.forEach((index) => {
    const row = Math.floor(index / cols);
    const col = index % cols;
    const tile = matrix.get(row, col);
    if (tile) tile.isMine = true;
  });

  return matrix;
}

function cloneMatrix(matrix: Matrix<Tile>) {
  return new Matrix<Tile>(matrix.rows, matrix.cols, (r, c) => {
    const t = matrix.get(r, c) ?? new Tile("tile0");
    return new Tile(t.texture, t.isMine, t.isOpen, t.isFlagged);
  });
}

const numberTexture = (count: number): TileTexture => {
  if (count <= 0) return "tile9";
  if (count >= 8) return "tile8";
  return (`tile${count}` as TileTexture);
};

export default function App() {
  const [state, setState] = useState<GameState | null>(null);
  const [gridSize, setGridSize] = useState({ rows: 9, cols: 9 });
  const [mineCount, setMineCount] = useState(10);
  const [localMatrix, setLocalMatrix] = useState(() =>
    createMatrix(9, 9, 10)
  );
  const [charPos, setCharPos] = useState({ row: 0, col: 0 });
  const [status, setStatus] = useState<GameStatus>("playing");
  const [firstMove, setFirstMove] = useState(true);
  const [gameStarted, setGameStarted] = useState(false);
  const [timer, setTimer] = useState(0);
  const [isFacePressed, setIsFacePressed] = useState(false);
  const [pressedArrows, setPressedArrows] = useState<Set<string>>(new Set());
  const [animationFrame, setAnimationFrame] = useState(0);
  const [lastDirection, setLastDirection] = useState<"Up" | "Down" | "Left" | "Right">("Down");
  const [isMoving, setIsMoving] = useState(false);
  const [placingFlagDirection, setPlacingFlagDirection] = useState<"Up" | "Down" | "Left" | "Right" | "UpLeft" | "UpRight" | "DownLeft" | "DownRight" | null>(null);
  const [placeFlagFrameIndex, setPlaceFlagFrameIndex] = useState(0);
  const [isRemovingFlag, setIsRemovingFlag] = useState(false);
  const GRID_SIZE = 16; // Tile size in pixels

  // Count flags in the matrix
  const flagCount = localMatrix.data.flat().filter((tile: Tile) => tile.isFlagged).length;
  const remainingMines = mineCount - flagCount;

  // Timer effect
  useEffect(() => {
    if (status === "playing" && gameStarted) {
      const interval = setInterval(() => {
        setTimer((prev) => Math.min(prev + 1, 999));
      }, 1000);
      return () => clearInterval(interval);
    }
  }, [status, gameStarted]);

  // Animation effect
  useEffect(() => {
    if (!gameStarted) return;
    
    const animationInterval = setInterval(() => {
      setAnimationFrame((prev) => (prev + 1) % 100);
    }, 50); // ~20fps for animation
    
    return () => clearInterval(animationInterval);
  }, [gameStarted]);

  // Place flag animation effect
  useEffect(() => {
    if (placingFlagDirection === null) return;
    
    const timeout = setTimeout(() => {
      if (isRemovingFlag) {
        // Reverse animation: go from 5 down to 0
        if (placeFlagFrameIndex > 0) {
          setPlaceFlagFrameIndex((prev) => prev - 1);
        } else {
          setPlacingFlagDirection(null);
          setPlaceFlagFrameIndex(0);
          setIsRemovingFlag(false);
        }
      } else {
        // Forward animation: go from 0 to 5
        if (placeFlagFrameIndex < 5) {
          setPlaceFlagFrameIndex((prev) => prev + 1);
        } else {
          setPlacingFlagDirection(null);
          setPlaceFlagFrameIndex(0);
        }
      }
    }, 75); // Each frame shows for 75ms
    
    return () => clearTimeout(timeout);
  }, [placingFlagDirection, placeFlagFrameIndex, isRemovingFlag]);

  useEffect(() => {
    fetch("http://localhost:3000/state")
      .then((res) => res.json())
      .then((data: GameState) => setState(data))
      .catch(() => setState(null));
  }, []);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (status !== "playing") return;
      
      const key = e.key.toLowerCase();

      if (key.startsWith("arrow")) {
        e.preventDefault();
        setPressedArrows((prev) => {
          const next = new Set(prev);
          next.add(key);
          return next;
        });
        return;
      }

      if (key === "w") moveCharacter(-1, 0);
      if (key === "s") moveCharacter(1, 0);
      if (key === "a") moveCharacter(0, -1);
      if (key === "d") moveCharacter(0, 1);
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      const key = e.key.toLowerCase();
      if (!key.startsWith("arrow")) return;

      setPressedArrows((prev) => {
        const current = new Set(prev);
        // Use current (including released key) to determine direction
        const up = current.has("arrowup");
        const down = current.has("arrowdown");
        const left = current.has("arrowleft");
        const right = current.has("arrowright");

        let dr = 0;
        let dc = 0;
        let isDiagonal = false;
        let isSingle = false;

        if (up && right) {
          dr = -1;
          dc = 1;
          isDiagonal = true;
        } else if (up && left) {
          dr = -1;
          dc = -1;
          isDiagonal = true;
        } else if (down && right) {
          dr = 1;
          dc = 1;
          isDiagonal = true;
        } else if (down && left) {
          dr = 1;
          dc = -1;
          isDiagonal = true;
        } else if (up) {
          dr = -1;
          dc = 0;
          isSingle = current.size === 1;
        } else if (down) {
          dr = 1;
          dc = 0;
          isSingle = current.size === 1;
        } else if (left) {
          dr = 0;
          dc = -1;
          isSingle = current.size === 1;
        } else if (right) {
          dr = 0;
          dc = 1;
          isSingle = current.size === 1;
        }

        if (isDiagonal && (dr !== 0 || dc !== 0)) {
          toggleFlagAt(charPos.row + dr, charPos.col + dc);
          return new Set();
        }

        if (isSingle && (dr !== 0 || dc !== 0)) {
          toggleFlagAt(charPos.row + dr, charPos.col + dc);
        }

        current.delete(key);
        return current;
      });
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [gridSize, status, localMatrix, charPos, remainingMines, gameStarted]);

  useEffect(() => {
    if (status === "playing" && gameStarted) {
      revealAt(charPos.row, charPos.col);
    }
  }, [charPos, status, gameStarted]);

  const setDifficulty = (rows: number, cols: number, mines: number) => {
    setGridSize({ rows, cols });
    setMineCount(mines);
    setLocalMatrix(createMatrix(rows, cols, mines));
    setCharPos({ row: 0, col: 0 });
    setStatus("playing");
    setFirstMove(true);
    setGameStarted(false);
    setTimer(0);
  };

  const getIdleFrame = () => {
    const frameIndex = Math.floor((animationFrame / 100) * 4) % 4;
    return IDLE_COORDS[`idle${frameIndex}`];
  };

  const getWalkFrame = () => {
    const directionMap: Record<string, string> = {
      "Up": "walkUp",
      "Down": "walkDown",
      "Left": "walkLeft",
      "Right": "walkRight"
    };
    const prefix = directionMap[lastDirection] || "walkDown";
    const frameIndex = Math.floor((animationFrame / 100) * 11) % 11;
    return WALK_COORDS[`${prefix}${frameIndex}`];
  };

  const getPlaceFlagFrame = () => {
    const directionMap: Record<string, string> = {
      "Up": "placeflagTop",
      "Down": "placeflagBottom",
      "Left": "placeflagLeft",
      "Right": "placeflagRight",
      "UpLeft": "placeflagTopLeft",
      "UpRight": "placeflagTopRight",
      "DownLeft": "placeflagBottomLeft",
      "DownRight": "placeflagBottomRight"
    };
    const prefix = directionMap[placingFlagDirection || "Down"] || "placeflagBottom";
    return PLACEFLAG_COORDS[`${prefix}${placeFlagFrameIndex}`];
  };

  const getCurrentCharacterSprite = () => {
    if (placingFlagDirection !== null) {
      return {
        spriteSheet: PLACEFLAG_SPRITE_SHEET,
        coords: getPlaceFlagFrame()
      };
    } else if (isMoving) {
      return {
        spriteSheet: WALK_SPRITE_SHEET,
        coords: getWalkFrame()
      };
    } else {
      return {
        spriteSheet: IDLE_SPRITE_SHEET,
        coords: getIdleFrame()
      };
    }
  };

  const renderThreeDigitNumber = (value: number) => {
    const digits = Math.min(Math.max(value, 0), 999).toString().padStart(3, '0').split('');
    return (
      <div style={{ display: 'flex', gap: 2 }}>
        {digits.map((digit, idx) => {
          const coords = NUMBER_COORDS[`number${digit}`];
          const width = coords.x2 - coords.x1 + 1;
          const height = coords.y2 - coords.y1 + 1;
          return (
            <div
              key={idx}
              style={{
                width,
                height,
                backgroundImage: `url(${SPRITE_SHEET})`,
                backgroundPosition: `-${coords.x1}px -${coords.y1}px`,
                backgroundSize: 'auto'
              }}
            />
          );
        })}
      </div>
    );
  };

  const getFaceCoords = () => {
    if (isFacePressed) return FACE_COORDS.face2;
    if (status === "won") return FACE_COORDS.face3;
    if (status === "lost") return FACE_COORDS.face4;
    return FACE_COORDS.face1;
  };

  const moveCharacter = (dr: number, dc: number) => {
    if (status !== "playing") return;
    
    // Update direction
    if (dr === -1) setLastDirection("Up");
    else if (dr === 1) setLastDirection("Down");
    else if (dc === -1) setLastDirection("Left");
    else if (dc === 1) setLastDirection("Right");
    
    setIsMoving(true);
    setCharPos((prev) => {
      const newRow = Math.min(gridSize.rows - 1, Math.max(0, prev.row + dr));
      const newCol = Math.min(gridSize.cols - 1, Math.max(0, prev.col + dc));
      return { row: newRow, col: newCol };
    });
    
    // Stop moving animation after a short delay
    setTimeout(() => setIsMoving(false), 200);
  };

  const renderKeyButton = (
    coords: { x1: number; y1: number; x2: number; y2: number },
    onClick: () => void,
    ariaLabel: string
  ) => {
    const width = coords.x2 - coords.x1 + 1;
    const height = coords.y2 - coords.y1 + 1;
    return (
      <button
        type="button"
        onClick={onClick}
        aria-label={ariaLabel}
        style={{
          width,
          height,
          padding: 0,
          border: "none",
          backgroundColor: "transparent",
          backgroundImage: `url(${SPRITE_SHEET})`,
          backgroundPosition: `-${coords.x1}px -${coords.y1}px`,
          backgroundSize: "auto",
          cursor: "pointer"
        }}
      />
    );
  };

  const toggleFlagAt = (row: number, col: number) => {
    if (!gameStarted || status !== "playing") return;
    if (!localMatrix.inBounds(row, col)) return;

    // Check if tile is legal for flagging before animating
    const tile = localMatrix.get(row, col);
    if (!tile || tile.isOpen) return;
    if (!tile.isFlagged && remainingMines <= 0) return;

    // Calculate direction for animation
    const dr = row - charPos.row;
    const dc = col - charPos.col;
    
    let direction: "Up" | "Down" | "Left" | "Right" | "UpLeft" | "UpRight" | "DownLeft" | "DownRight" | null = null;
    if (dr === -1 && dc === 0) direction = "Up";
    else if (dr === 1 && dc === 0) direction = "Down";
    else if (dr === 0 && dc === -1) direction = "Left";
    else if (dr === 0 && dc === 1) direction = "Right";
    else if (dr === -1 && dc === -1) direction = "UpLeft";
    else if (dr === -1 && dc === 1) direction = "UpRight";
    else if (dr === 1 && dc === -1) direction = "DownLeft";
    else if (dr === 1 && dc === 1) direction = "DownRight";
    
    // Check if flag already exists to determine animation direction
    const isFlagPresent = tile.isFlagged;

    // Trigger animation
    if (direction) {
      setPlacingFlagDirection(direction);
      setPlaceFlagFrameIndex(isFlagPresent ? 5 : 0);
      setIsRemovingFlag(isFlagPresent);
    }

    setLocalMatrix((prev) => {
      const next = cloneMatrix(prev);
      const tile = next.get(row, col);
      if (!tile || tile.isOpen) return prev;
      if (!tile.isFlagged && remainingMines <= 0) return prev;

      tile.isFlagged = !tile.isFlagged;
      tile.setTexture(tile.isFlagged ? "tilef" : "tile0");
      return next;
    });
  };

  const toggleFlag = (row: number, col: number) => {
    if (!gameStarted) {
      // Start game on first click
      setGameStarted(true);
      setCharPos({ row, col });
      revealAt(row, col);
      return;
    }

    if (status !== "playing") return;

    // Check if tile is within 3x3 area around character
    const rowDist = Math.abs(row - charPos.row);
    const colDist = Math.abs(col - charPos.col);
    if (rowDist > 1 || colDist > 1) return;

    setLocalMatrix((prev) => {
      const next = cloneMatrix(prev);
      const tile = next.get(row, col);
      if (!tile || tile.isOpen) return prev;
      
      // Check if we can place more flags
      if (!tile.isFlagged && remainingMines <= 0) return prev;
      
      tile.isFlagged = !tile.isFlagged;
      tile.setTexture(tile.isFlagged ? "tilef" : "tile0");
      return next;
    });
  };

  const revealAt = (row: number, col: number) => {
    if (status !== "playing") return;
    if (firstMove) setFirstMove(false);

    setLocalMatrix((prev) => {
      const next = cloneMatrix(prev);
      const tile = next.get(row, col);
      if (!tile || tile.isOpen || tile.isFlagged) return prev;

      if (firstMove && tile.isMine) {
        relocateMine(next, row, col);
      }

      if (tile.isMine) {
        revealAllMines(next);
        setStatus("lost");
        return next;
      }

      floodReveal(next, row, col);

      if (checkWin(next, mineCount)) {
        setStatus("won");
      }

      return next;
    });
  };

  const relocateMine = (matrix: Matrix<Tile>, row: number, col: number) => {
    for (let r = 0; r < matrix.rows; r += 1) {
      for (let c = 0; c < matrix.cols; c += 1) {
        const t = matrix.get(r, c);
        if (t && !t.isMine && (r !== row || c !== col)) {
          t.isMine = true;
          const original = matrix.get(row, col);
          if (original) original.isMine = false;
          return;
        }
      }
    }
  };

  const revealAllMines = (matrix: Matrix<Tile>) => {
    for (let r = 0; r < matrix.rows; r += 1) {
      for (let c = 0; c < matrix.cols; c += 1) {
        const t = matrix.get(r, c);
        if (t?.isMine) {
          t.isOpen = true;
          t.setTexture("tileb2");
        }
      }
    }
  };

  const countAdjacentMines = (matrix: Matrix<Tile>, row: number, col: number) =>
    matrix
      .neighbors(row, col)
      .reduce((acc, [r, c]) => (matrix.get(r, c)?.isMine ? acc + 1 : acc), 0);

  const floodReveal = (matrix: Matrix<Tile>, row: number, col: number) => {
    const stack: Array<[number, number]> = [[row, col]];
    while (stack.length) {
      const [r, c] = stack.pop()!;
      const t = matrix.get(r, c);
      if (!t || t.isOpen || t.isFlagged || t.isMine) continue;

      const count = countAdjacentMines(matrix, r, c);
      t.isOpen = true;
      t.setTexture(numberTexture(count));

      if (count === 0) {
        matrix.neighbors(r, c).forEach(([nr, nc]) => {
          const nt = matrix.get(nr, nc);
          if (nt && !nt.isOpen && !nt.isMine) stack.push([nr, nc]);
        });
      }
    }
  };

  const checkWin = (matrix: Matrix<Tile>, mines: number) => {
    let opened = 0;
    for (let r = 0; r < matrix.rows; r += 1) {
      for (let c = 0; c < matrix.cols; c += 1) {
        if (matrix.get(r, c)?.isOpen) opened += 1;
      }
    }
    return opened === matrix.rows * matrix.cols - mines;
  };

  return (
    <div style={{ padding: 12, fontFamily: "sans-serif" }}>
      {/* <h1>MineSticker</h1>
      <p>React + NestJS starter with shared game classes.</p>

      <section style={{ marginTop: 16 }}>
        <h2>Server State</h2>
        <pre style={{ background: "#f4f4f4", padding: 12 }}>
          {state ? JSON.stringify(state, null, 2) : "No state loaded"}
        </pre>
      </section> */}

      <section style={{ marginTop: 16 }}>
        <h2>Minesweeper (But with TDL)</h2>
        <div style={{ display: "flex", gap: 8, marginBottom: 8 }}>
          <button type="button" onClick={() => setDifficulty(9, 9, 10)}>
            Easy 9x9
          </button>
          <button type="button" onClick={() => setDifficulty(16, 16, 40)}>
            Normal 16x16
          </button>
          <button type="button" onClick={() => setDifficulty(16, 30, 99)}>
            Hard 30x16
          </button>
        </div>
        
        {/* Game board with counter and matrix */}
        <div style={{
          border: "8px solid",
          borderTopColor: "#ffffff",
          borderLeftColor: "#ffffff",
          borderBottomColor: "#808080",
          borderRightColor: "#808080",
          width: "fit-content",
          boxShadow: "4px 4px 8px rgba(0, 0, 0, 0.3)"
        }}>
          {/* Counter displays */}
          <div style={{ 
            border: "8px solid #C6C6C6",
            width: "fit-content"
          }}>
            <div style={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              width: gridSize.cols * 16 - 8,
              background: "#C6C6C6",
              border: "4px solid #808080",
              borderRightColor: "#ffffff",
              borderBottomColor: "#ffffff",
              padding: "4px 4px",
              boxSizing: "content-box",
              position: "relative"
            }}>
              {renderThreeDigitNumber(remainingMines)}
              <button
                type="button"
                onMouseDown={() => setIsFacePressed(true)}
                onMouseUp={() => setIsFacePressed(false)}
                onMouseLeave={() => setIsFacePressed(false)}
                onClick={() => setDifficulty(gridSize.rows, gridSize.cols, mineCount)}
                style={{
                  position: "absolute",
                  left: "50%",
                  transform: "translateX(-50%)",
                  width: 24,
                  height: 24,
                  padding: 0,
                  border: "none",
                  backgroundColor: "transparent",
                  backgroundImage: `url(${SPRITE_SHEET})`,
                  backgroundPosition: `-${getFaceCoords().x1}px -${getFaceCoords().y1}px`,
                  backgroundSize: "auto",
                  cursor: "pointer"
                }}
                aria-label="Reset game"
              />
              {renderThreeDigitNumber(timer)}
            </div>
          </div>

          <div style={{ border: "8px solid #C6C6C6", width: "fit-content" }}>
            <div
              style={{
                display: "grid",
                gridTemplateColumns: `repeat(${gridSize.cols}, 16px)`,
                position: "relative",
                width: "fit-content",
                background: "#f0f0f0",
                border: "4px solid #808080",
                borderRightColor: "#ffffff",
                borderBottomColor: "#ffffff"
              }}
            >
          {localMatrix.data.flat().map((tile: Tile, i: number) => {
            const { x1, y1, x2, y2 } = tile.coords;
            const width = x2 - x1 + 1;
            const height = y2 - y1 + 1;
            const row = Math.floor(i / gridSize.cols);
            const col = i % gridSize.cols;

            return (
              <div
                key={i}
                onClick={() => toggleFlag(row, col)}
                style={{
                  width,
                  height,
                  backgroundImage: `url(${SPRITE_SHEET})`,
                  backgroundPosition: `-${x1}px -${y1}px`,
                  backgroundSize: "auto",
                  cursor: "pointer"
                }}
              />
            );
          })}
          {gameStarted && (
            <div
              style={{
                position: "absolute",
                top: charPos.row * GRID_SIZE - (112 - 16) / 2,
                left: charPos.col * GRID_SIZE - (112 - 16) / 2,
                width: 112,
                height: 112,
                backgroundImage: `url(${getCurrentCharacterSprite().spriteSheet})`,
                backgroundPosition: `-${getCurrentCharacterSprite().coords.x1}px -${getCurrentCharacterSprite().coords.y1}px`,
                backgroundSize: "auto",
                pointerEvents: "none",
                zIndex: 10
              }}
            />
          )}
          
          </div>
        </div>
        </div>
        {/* <div style={{ marginTop: 12, fontSize: 12 }}>
          <p>Position: Row {charPos.row}, Col {charPos.col}</p>
          <p style={{ color: "#666" }}>Use WASD to move</p>
          <p style={{ color: status === "won" ? "#00AA00" : status === "lost" ? "#FF0000" : "#666", fontWeight: status !== "playing" ? "bold" : "normal" }}>
            Status: {status}
          </p>
        </div> */}
        <div style={{ marginTop: 16, display: "flex", gap: 24, flexWrap: "wrap" }}>
          <div>
            <div style={{ fontSize: 12, marginBottom: 6 }}></div>
            <div
              style={{
                display: "grid",
                gridTemplateColumns: "repeat(3, 24px)",
                gap: 4
              }}
            >
              <div style={{ width: 24, height: 24 }} />
              {renderKeyButton(KEY_COORDS.keyW, () => moveCharacter(-1, 0), "Move up")}
              <div style={{ width: 24, height: 24 }} />
              {renderKeyButton(KEY_COORDS.keyA, () => moveCharacter(0, -1), "Move left")}
              <div style={{ width: 24, height: 24 }} />
              {renderKeyButton(KEY_COORDS.keyD, () => moveCharacter(0, 1), "Move right")}
              <div style={{ width: 24, height: 24 }} />
              {renderKeyButton(KEY_COORDS.keyS, () => moveCharacter(1, 0), "Move down")}
              <div style={{ width: 24, height: 24 }} />
            </div>
          </div>

          <div>
            <div style={{ fontSize: 12, marginBottom: 6 }}></div>
            <div
              style={{
                display: "grid",
                gridTemplateColumns: "repeat(3, 24px)",
                gap: 4
              }}
            >
              {renderKeyButton(KEY_COORDS.arrowUpLeft, () => toggleFlagAt(charPos.row - 1, charPos.col - 1), "Flag up-left")}
              {renderKeyButton(KEY_COORDS.arrowUp, () => toggleFlagAt(charPos.row - 1, charPos.col), "Flag up")}
              {renderKeyButton(KEY_COORDS.arrowUpRight, () => toggleFlagAt(charPos.row - 1, charPos.col + 1), "Flag up-right")}
              {renderKeyButton(KEY_COORDS.arrowLeft, () => toggleFlagAt(charPos.row, charPos.col - 1), "Flag left")}
              <div style={{ width: 24, height: 24 }} />
              {renderKeyButton(KEY_COORDS.arrowRight, () => toggleFlagAt(charPos.row, charPos.col + 1), "Flag right")}
              {renderKeyButton(KEY_COORDS.arrowDownLeft, () => toggleFlagAt(charPos.row + 1, charPos.col - 1), "Flag down-left")}
              {renderKeyButton(KEY_COORDS.arrowDown, () => toggleFlagAt(charPos.row + 1, charPos.col), "Flag down")}
              {renderKeyButton(KEY_COORDS.arrowDownRight, () => toggleFlagAt(charPos.row + 1, charPos.col + 1), "Flag down-right")}
            </div>
          </div>
        </div>
      </section>

      {/* <section style={{ marginTop: 24 }}>
        <h2>Texture Gallery</h2>
        
        <h3>Faces</h3>
        <div style={{ display: "flex", gap: 16, marginBottom: 16, flexWrap: "wrap" }}>
          {Object.entries(FACE_COORDS).map(([name, coords]) => {
            const width = coords.x2 - coords.x1 + 1;
            const height = coords.y2 - coords.y1 + 1;
            return (
              <div key={name} style={{ display: "flex", flexDirection: "column", alignItems: "center" }}>
                <div
                  style={{
                    width,
                    height,
                    backgroundImage: `url(${SPRITE_SHEET})`,
                    backgroundPosition: `-${coords.x1}px -${coords.y1}px`,
                    backgroundSize: "auto",
                    border: "2px solid #333",
                    marginBottom: 8
                  }}
                />
                <span style={{ fontSize: 12, fontWeight: "bold" }}>{name}</span>
              </div>
            );
          })}
        </div>

        <h3>Tiles</h3>
        <div style={{ display: "flex", gap: 12, marginBottom: 16, flexWrap: "wrap" }}>
          {Object.entries(TILE_COORDS).map(([name, coords]) => {
            const width = coords.x2 - coords.x1 + 1;
            const height = coords.y2 - coords.y1 + 1;
            return (
              <div key={name} style={{ display: "flex", flexDirection: "column", alignItems: "center" }}>
                <div
                  style={{
                    width,
                    height,
                    backgroundImage: `url(${SPRITE_SHEET})`,
                    backgroundPosition: `-${coords.x1}px -${coords.y1}px`,
                    backgroundSize: "auto",
                    border: "2px solid #333",
                    marginBottom: 8
                  }}
                />
                <span style={{ fontSize: 11, fontWeight: "bold" }}>{name}</span>
              </div>
            );
          })}
        </div>

        <h3>Numbers</h3>
        <div style={{ display: "flex", gap: 8, marginBottom: 16, flexWrap: "wrap" }}>
          {Object.entries(NUMBER_COORDS).map(([name, coords]) => {
            const width = coords.x2 - coords.x1 + 1;
            const height = coords.y2 - coords.y1 + 1;
            return (
              <div key={name} style={{ display: "flex", flexDirection: "column", alignItems: "center" }}>
                <div
                  style={{
                    width,
                    height,
                    backgroundImage: `url(${SPRITE_SHEET})`,
                    backgroundPosition: `-${coords.x1}px -${coords.y1}px`,
                    backgroundSize: "auto",
                    border: "2px solid #333",
                    marginBottom: 6
                  }}
                />
                <span style={{ fontSize: 10, fontWeight: "bold" }}>{name}</span>
              </div>
            );
          })}
        </div>
      </section> */}
    </div>
  );
}
